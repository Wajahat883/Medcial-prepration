import { StudentPerformanceDetail } from '../models/StudentPerformanceDetail';
import { RevisionBucket } from '../models/RevisionBucket';
import { Question } from '../models/Question';

export async function generateRevisionBucketsForUser(userId: string) {
  const recent = await StudentPerformanceDetail.find({ userId }).sort({ attemptedAt: -1 }).limit(1000).lean();

  // Buckets
  const slowCorrect: any[] = [];
  const incorrectConfident: any[] = [];
  const highYieldLowAcc: any[] = [];
  const almostCorrect: any[] = [];

  for (const r of recent) {
    // slow correct
    if (r.attemptCount === 1 && r.timeTaken > 90 && (r.errorType === 'none' || !r.errorType)) slowCorrect.push(r.questionId);
    // incorrect but confident
    if ((r.errorType && r.errorType !== 'none') && (r.confidenceLevel || 0) >= 70) incorrectConfident.push(r.questionId);
    // almost correct (second-best answer) -> placeholder: marked by correctedOnRetry true
    if ((r.errorType && r.errorType !== 'none') && r.correctedOnRetry) almostCorrect.push(r.questionId);
  }

  // High-yield low-accuracy: find topics with frequent recalls (approx using Question.examinerFavored)
  const qids = Array.from(new Set(recent.map(r => String(r.questionId))));
  const qs = await Question.find({ _id: { $in: qids }, examinerFavored: true }).select('_id').lean();
  for (const q of qs) {
    const attempts = recent.filter(r => String(r.questionId) === String(q._id));
    const acc = attempts.length ? (attempts.filter(a => !a.errorType || a.errorType === 'none').length / attempts.length) : 1;
    if (acc < 0.7) highYieldLowAcc.push(q._id);
  }

  // persist buckets (replace existing)
  await RevisionBucket.deleteMany({ userId });
  const created: any[] = [];
  if (slowCorrect.length) created.push(await RevisionBucket.create({ userId, bucketType: 'slow_correct', questions: slowCorrect, priorityLevel: 3, autoGeneratedAt: new Date() }));
  if (incorrectConfident.length) created.push(await RevisionBucket.create({ userId, bucketType: 'incorrect_confident', questions: incorrectConfident, priorityLevel: 4, autoGeneratedAt: new Date() }));
  if (highYieldLowAcc.length) created.push(await RevisionBucket.create({ userId, bucketType: 'high_yield_low_accuracy', questions: highYieldLowAcc, priorityLevel: 5, autoGeneratedAt: new Date() }));
  if (almostCorrect.length) created.push(await RevisionBucket.create({ userId, bucketType: 'almost_correct', questions: almostCorrect, priorityLevel: 2, autoGeneratedAt: new Date() }));

  return created;
}
